# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Binary file access
#' 
#' This function extracts data points from a binary file based on time points and a window
#' which will cut out the data of and concatenates them based on the channels.
#' 
#' @param FILENAME A string as path to file with single "/".
#' @param spikePoints An integer vector for time points which correspond to sampling points.
#' @param WINDOW An integer indicating points taken before and after time point (default = 40).
#' @param CHANNELCOUNT An integer indicating number of channels in recording (default = 32).
#' @param CACHESIZE An integer indicating the size of cache used for buffering file in bytes (default = 512000).
#' @param BYTECODE An integer indicating number of bytes coding for bit rate (8bit = 1, 16bit = 2 etc.) (default = 2).
#' @return Returns an armadillo cube with extracted spikes.
#' @export
BinaryFileAccess <- function(FILENAME, spikePoints, WINDOW = 40L, CHANNELCOUNT = 32L, CACHESIZE = 512000L, BYTECODE = 2L) {
    .Call('_InVivoR_BinaryFileAccess', PACKAGE = 'InVivoR', FILENAME, spikePoints, WINDOW, CHANNELCOUNT, CACHESIZE, BYTECODE)
}

#' Decimate
#' 
#' This function downsamples a signal using a preset FIR filter which should be filtering at half the target frequency.
#'
#' @param SIGNAL A numeric vector with length N.
#' @param FIR_FILTER A predefined FIR filter as numeric vector (low-pass filter for <= target frequency).
#' @param M An int representing downsampling factor.
#' @return Returns a numeric vector with length N/M.
#' @export
decimate <- function(SIGNAL, FIR_FILTER, M) {
    .Call('_InVivoR_decimate', PACKAGE = 'InVivoR', SIGNAL, FIR_FILTER, M)
}

#' ERP (event-related potential) extraction
#' 
#' This function returns a matrix with extracted traces for any given range. 
#' The range is has to be provided in form of onset indeces and end indeces. 
#' Additional information can be provided to adjust for sampling differences 
#' between range points and trace sampling frequency. If required the window 
#' is proportionally elongated to include Pre/Post times.
#'
#' @param Trace A numeric vector which is used for extraction.
#' @param Onset An integer vector with onset sample indeces.
#' @param End An integer vector with end sample indeces.
#' @param SamplingFreqStim A double indicating the sampling frequency of onset/end indeces.
#' @param SamplingFreqTrace A double indicating the sampling frequency of the trace.
#' @param PrePhase A bool indicating if pre-onset timings should be included (default = false).
#' @param PostPhase A bool indicating if post-end timings should be included (default = false).
#' @return Returns a matrix with extracted ERPs.
#' @export
ERPMat <- function(Trace, Onset, End, SamplingFreqStim = 0, SamplingFreqTrace = 0, PrePhase = FALSE, PostPhase = FALSE) {
    .Call('_InVivoR_ERPMat', PACKAGE = 'InVivoR', Trace, Onset, End, SamplingFreqStim, SamplingFreqTrace, PrePhase, PostPhase)
}

#' Wrapper for ERP (event-related potential) extraction
#' 
#' This function returns a list which includes the frequencies and matrices 
#' with extracted traces for any given range. The range is has to be provided
#' in form of onset indeces and end indeces. Additional information can be 
#' provided to adjust for sampling differences between range points and trace 
#' sampling frequency. If required the window is proportionally elongated to 
#' include Pre/Post times.
#'
#' @param Trace A numeric vector which is used for extraction.
#' @param BlockMat The stimulation block matrix from StimulusSequence() including onset and end timings.
#' @param SamplingFreqStim A double indicating the sampling frequency of onset/end indeces.
#' @param SamplingFreqTrace A double indicating the sampling frequency of the trace.
#' @param PrePhase A bool indicating if pre-onset timings should be included (default = true).
#' @param PostPhase A bool indicating if post-end timings should be included (default = true).
#' @param FixStartLength A double indicating the starting length when fixed window is used (default = 0).
#' @param WindowLength A double indicating the time block in seconds (default = 0).
#' @return Returns a list which includes stimulation frequencies for hyperblocks and the corresponding ERP matrices.
#' @export
ERPList <- function(Trace, BlockMat, SamplingFreqStim = 0, SamplingFreqTrace = 0, PrePhase = TRUE, PostPhase = TRUE, FixStartLength = 0, WindowLength = 0) {
    .Call('_InVivoR_ERPList', PACKAGE = 'InVivoR', Trace, BlockMat, SamplingFreqStim, SamplingFreqTrace, PrePhase, PostPhase, FixStartLength, WindowLength)
}

arma_gaussian <- function(sd, width, SamplingRateOut, SpikeTimings, StartTime, EndTime) {
    .Call('_InVivoR_arma_gaussian', PACKAGE = 'InVivoR', sd, width, SamplingRateOut, SpikeTimings, StartTime, EndTime)
}

arma_gaussian_kernel <- function(sd, width, SamplingRateOut) {
    .Call('_InVivoR_arma_gaussian_kernel', PACKAGE = 'InVivoR', sd, width, SamplingRateOut)
}

arma_gaussian_loop <- function(sd, SamplingRateOut, SpikeTimings, StartTime, EndTime) {
    .Call('_InVivoR_arma_gaussian_loop', PACKAGE = 'InVivoR', sd, SamplingRateOut, SpikeTimings, StartTime, EndTime)
}

BAKS <- function(SpikeTimings, Time, alpha, beta) {
    .Call('_InVivoR_BAKS', PACKAGE = 'InVivoR', SpikeTimings, Time, alpha, beta)
}

OKS <- function(SpikeTimings, Time, alpha, beta) {
    .Call('_InVivoR_OKS', PACKAGE = 'InVivoR', SpikeTimings, Time, alpha, beta)
}

BAKS_fast <- function(SpikeTimings, Time, alpha, beta) {
    .Call('_InVivoR_BAKS_fast', PACKAGE = 'InVivoR', SpikeTimings, Time, alpha, beta)
}

BAKS_fast_new <- function(SpikeTimings, Time, alpha, beta) {
    .Call('_InVivoR_BAKS_fast_new', PACKAGE = 'InVivoR', SpikeTimings, Time, alpha, beta)
}

#' @useDynLib InVivoR
#' @importFrom Rcpp sourceCpp
NULL

#' Modulation index analysis
#' 
#' This function returns a list including a modulation index matrix, the phase frequency and the power frequency.
#' there are leading NA, marking the leadings NA as TRUE and
#' everything else as FALSE.
#'
#' @param PowerMatRaw A matrix with power.
#' @param PhaseMatRaw A matrix with phase.
#' @param PowerPeriods A double vector with unique periods (1/Frequency) for power matrix.
#' @param PhasePeriods A double vector with unique periods (1/Frequency) for phase matrix.
#' @param BIN_NUMBER An integer indicating in how many parts phase should be split.
#' @param PHASE_FREQ_START A double indicating starting frequency (1/period) for phase.
#' @param PHASE_FREQ_END A double indicating end frequency (1/period) for phase.
#' @param POWER_FREQ_START A double indicating starting frequency (1/period) for power.
#' @param POWER_FREQ_END A A double indicating end frequency (1/period) for power.
#' @param CORES An integer indicating number of threads used (multicore support).
#' @return Returns a list containing the modulation index matrix and vectors containing its axis (Powerfrequency and Phasefrequency)
#' @export
MI <- function(PowerMatRaw, PhaseMatRaw, PowerPeriods, PhasePeriods, BIN_NUMBER, PHASE_FREQ_START, PHASE_FREQ_END, POWER_FREQ_START, POWER_FREQ_END, CORES) {
    .Call('_InVivoR_MI', PACKAGE = 'InVivoR', PowerMatRaw, PhaseMatRaw, PowerPeriods, PhasePeriods, BIN_NUMBER, PHASE_FREQ_START, PHASE_FREQ_END, POWER_FREQ_START, POWER_FREQ_END, CORES)
}

#' Phase lock analysis
#' 
#' This function computes the phase lock using the Rho vector length 
#' (strength of the locking) and the circular mean phase from a list containing 
#' wavelet transforms of epochs. The input list has to be flattend (vectorised) 
#' first.
#' 
#' @param x A cube of phases (radians) with slices as different ERPs.
#' @param CORES An int indicating the number of threads used (default = 1).
#' @return Returns a list containing a matrix with Rho vector lengths and a matrix with the corresponding circular mean.
#' @export
PhaseListAnalysis <- function(x, CORES = 1L) {
    .Call('_InVivoR_PhaseListAnalysis', PACKAGE = 'InVivoR', x, CORES)
}

#' Matrix shuffle
#' 
#' This function shuffles the data independently of dimensions without 
#' resampling from a input matrix. It returns the probability for a any 
#' given value in a matrix to be larger than a random sample.
#' 
#' @param x A matrix.
#' @param SHUFFLES An int indicating the number of shuffles.
#' @param CORES An int indicating the number of threads used (default = 1).
#' @return Returns a matrix indicating the probability of value being larger than shuffled data.
#' @export
PhaseListAnalysisShuffle <- function(x, SHUFFLES = 200L, CORES = 1L) {
    .Call('_InVivoR_PhaseListAnalysisShuffle', PACKAGE = 'InVivoR', x, SHUFFLES, CORES)
}

#' Matrix resample
#' 
#' This function shuffles the data independently of dimensions with 
#' resampling from a input matrix. It returns the probability for a any 
#' given value in a matrix to be larger than a random sample.
#' 
#' @param x A matrix.
#' @param SHUFFLES An int indicating the number of shuffles.
#' @param CORES An int indicating the number of threads used (default = 1).
#' @return Returns a matrix indicating the probability of value being larger than shuffled data.
#' @export
PhaseListAnalysisResample <- function(x, SHUFFLES = 200L, CORES = 1L) {
    .Call('_InVivoR_PhaseListAnalysisResample', PACKAGE = 'InVivoR', x, SHUFFLES, CORES)
}

#' Butterworth filter c++
#' 
#' This function returns a filtered Signal.
#'
#' @param InputSignal A complex matrix from FFTW.
#' @param SamplingFrequency A double indicating sampling frequency.
#' @param ORDER An int as filtering order (default = 2).
#' @param f0 A double as cutoff frequency (default = 10).
#' @param type A string indicating the filter type ("low", "high"). The default is "low".
#' @param CORES An int indicating the number of threads used (default = 1).
#' @return Filtered signal as numeric vector.
#' @export
BWFiltCpp <- function(InputSignal, SamplingFrequency, ORDER = 2L, f0 = 10, type = "low", CORES = 1L) {
    .Call('_InVivoR_BWFiltCpp', PACKAGE = 'InVivoR', InputSignal, SamplingFrequency, ORDER, f0, type, CORES)
}

#' Stimulus sequence
#' 
#' This function analyses stimulus time series and extracts features which 
#' are returned in a list. Part of the output is the single stimulus feature
#' and the second part is a stimulus block summary.
#'
#' @param raw A numeric vector which is the stimulation over time as continues series.
#' @param sampling_frequency An integer indicating the sampling frequency.
#' @param threshold A double indicating the threshold of stimulus detection.
#' @param max_time_gap A double indicating the maximum time between blocks.
#' @return Returns a list with a matrix showing single pulse properperties and a matrix with block properties.
#' @export
StimulusSequence <- function(raw, sampling_frequency, threshold, max_time_gap) {
    .Call('_InVivoR_StimulusSequence', PACKAGE = 'InVivoR', raw, sampling_frequency, threshold, max_time_gap)
}

#' Morlet wavelet (time domain)
#' 
#' This function returns a complex morlet wavelet in the time domain. It can be 
#' used in convolution.
#'
#' @param t A numeric sequence of time (-t/2 to t/2) with steps of sampling frequency.
#' @param sigma A double indicating the shape parameter of the wavelet.
#' @return Morlet wavelet as complex vector.
#' @export
morletWavlet <- function(t, sigma) {
    .Call('_InVivoR_morletWavlet', PACKAGE = 'InVivoR', t, sigma)
}

#' Morlet wavelet (frequency domain)
#' 
#' This function returns a morlet wavelet in the frequency domain. It can be 
#' used for implementation via inverse FFT.
#'
#' @param angFreq A numeric sequence of angular frequency (0 to 2pi).
#' @param sigma A double indicating the shape parameter of the wavelet.
#' @return Morlet wavelet as numeric vector.
#' @export
morletWaveletFFT <- function(angFreq, sigma) {
    .Call('_InVivoR_morletWaveletFFT', PACKAGE = 'InVivoR', angFreq, sigma)
}

#' Application of morlet wavelet (frequency domain)
#' 
#' This function returns the convolution of a complex morlet daughter wavelet with the signal.
#' 
#' @param SignalFFT A complex vector of the signal FFT.
#' @param scale A double indicating the scale parameter of daughter wavelet.
#' @param morletFFT A vector of wavelet in frequency domain.
#' @param LNorm A double indicating the L normalisation (power of 1/LNorm, default = 2).
#' @return Morlet wavelet as numeric vector.
#' @export
morletWT <- function(SignalFFT, scale, morletFFT, LNorm = 2) {
    .Call('_InVivoR_morletWT', PACKAGE = 'InVivoR', SignalFFT, scale, morletFFT, LNorm)
}

#' Wavelet transform
#' 
#' This function performs a wavelet transform of a signal for different scales 
#' and returns a complex matrix from the convolution with a complex wavelet in 
#' the frequency domain.
#' 
#' @param Signal A numeric vector.
#' @param frequencies A vector indicating the frequencies which should be analysed.
#' @param samplingfrequency A double indicating the sampling frequency in Hz.
#' @param sigma A double indicating the shape parameter of the wavelet.
#' @param LNorm A double indicating the L normalisation (power of 1/LNorm, default = 2).
#' @param CORES An integer indicating number of threads used (default = 1). 
#' @return Wavelet transform as complex matrix.
#' 
#' @examples # test signal
#' testSignal <- sin(seq(0,32*pi, length.out = 4000))*6
#' testSignal <- testSignal+sin(seq(0,84*pi, length.out = 4000))*10
#' 
#' # apply wavelet tranform
#' WTmat <- WT(Signal = testSignal, frequencies = seq(from = 0.2,to = 20, by = 0.1),
#' samplingfrequency = 1e3, sigma = 12, LNorm = 2, CORES = 1)
#' 
#' # plot real part of WT
#' image(x = Re(WTmat), col = hcl.colors(n = 1000, palette = "viridis"), useRaster = TRUE)
#' 
#' # plot power of WT
#' image(x = abs(WTmat)^2, col = hcl.colors(n = 1000, palette = "viridis"), useRaster = TRUE)
#' 
#' # plot phase
#' image(x = atan2(y = Im(WTmat), x = Re(WTmat)),
#'       col = hcl.colors(n = 1000, palette = "viridis"),
#'       useRaster = TRUE)
#' 
#' @export
WT <- function(Signal, frequencies, samplingfrequency, sigma, LNorm = 2, CORES = 1L) {
    .Call('_InVivoR_WT', PACKAGE = 'InVivoR', Signal, frequencies, samplingfrequency, sigma, LNorm, CORES)
}

#' Wavelet transform (from ERP matrix)
#' 
#' This function performs a wavelet transform of a signal for different scales 
#' and returns a complex matrix from the convolution with a complex wavelet in 
#' the frequency domain.
#' 
#' @param ERPMat A numeric matrix with rows for ERP signals and columns as time domain.
#' @param frequencies A vector indicating the frequencies which should be analysed.
#' @param samplingfrequency A double indicating the sampling frequency in Hz.
#' @param sigma A double indicating the shape parameter of the wavelet.
#' @param LNorm A double indicating the L normalisation (power of 1/LNorm, default = 2).
#' @param CORES An integer indicating number of threads used (default = 1). 
#' @return Wavelet transform as complex cube (each slice is from one ERP).
#' 
#' @examples # Generate test signal
#' testSignal <- sin(seq(0,32*pi, length.out = 4000))*6
#' testSignal <- testSignal+sin(seq(0,84*pi, length.out = 4000))*10
#' 
#' # Generate ERP matrix
#' ERPmat <- ERPMat(Trace = testSignal, Onset = (1:10)*200, End = (1:10)*400)
#'   
#' # Apply WT to all ERPs
#' WTCube <- WTbatch(ERPMat = ERPmat,
#'                   frequencies = seq(0.2,20, 0.2),
#'                   samplingfrequency = 1000,
#'                   sigma = 6, LNorm = 2,
#'                   CORES = 1)
#'     
#' # Cube dimensions
#' dim(WTCube)
#'       
#' # Real part of wavelet transform for different ERPs
#' image(x = Re(WTCube[,,1]), col = hcl.colors(n = 1000, palette = "viridis"), useRaster = TRUE)
#' image(x = Re(WTCube[,,5]), col = hcl.colors(n = 1000, palette = "viridis"), useRaster = TRUE)
#' image(x = Re(WTCube[,,10]), col = hcl.colors(n = 1000, palette = "viridis"), useRaster = TRUE)
#' 
#' @export
WTbatch <- function(ERPMat, frequencies, samplingfrequency, sigma, LNorm = 2, CORES = 1L) {
    .Call('_InVivoR_WTbatch', PACKAGE = 'InVivoR', ERPMat, frequencies, samplingfrequency, sigma, LNorm, CORES)
}

#' Wavelet power matrix (from wavelet power cube)
#' 
#' This function computes the average power of several WT which can be returned as raw power
#' or as z-score. If the z-score is returned then every slice of the cube is z-transformed 
#' independently and the average is calculated in z-direction.
#' 
#' @param x A cube with power matrices each slice representing ERP.
#' @param ZScore A bool indicating if Z-score should be computed.
#' @return An average power matrix (raw or as z-score).
#' @export
PowerMat <- function(x, ZScore = FALSE) {
    .Call('_InVivoR_PowerMat', PACKAGE = 'InVivoR', x, ZScore)
}

#' Synchrosqueezed wavelet power matrix (from wavelet power matrix)
#' 
#' This function computes the synchrosqueezed wavelet transform as proposed by Daubechies and Maes (1996). Wavelet 
#' coefficients of the wavelet will be reassigned according to the instantaneous frequency in the transform.
#' 
#' @param WT A complex matrix representing the wavelet transform.
#' @param frequencies A vector indicating the frequencies which should be analysed.
#' @param samplingfrequency A double indicating the sampling frequency in Hz (default = 1000).
#' @param sigma A double indicating the shape parameter of the wavelet (default = 6).
#' @param CORES An integer indicating number of threads used (default = 1). 
#' @return A complex matrix representing the synchrosqueezed wavelet transform.
#' @export
Squeeze <- function(WT, frequencies, samplingfrequency = 1e3, sigma = 6.0, CORES = 1L) {
    .Call('_InVivoR_Squeeze', PACKAGE = 'InVivoR', WT, frequencies, samplingfrequency, sigma, CORES)
}

#' Average complex matrix (from wavelet power cube)
#' 
#' This function computes the average complex matrix of a complex cube.
#' 
#' @param x A cube with complex matrices each slice representing ERP.
#' @return An average complex matrix.
#' @export
CxCubeCollapse <- function(x) {
    .Call('_InVivoR_CxCubeCollapse', PACKAGE = 'InVivoR', x)
}

#' Smoothing complex wavelet matrix
#' 
#' This function computes the smoothened wavelet transform required 
#' for coherence calculation.
#' 
#' @param WT A complex matrix representing the wavelet transform.
#' @param frequencies A vector indicating the frequencies which should be analysed.
#' @param samplingfrequency A double indicating the sampling frequency in Hz (default = 1000).
#' @param sigma A double indicating the shape parameter of the wavelet (default = 6).
#' @param Ba A double indicating the smoothing factor in the scale domain (default = 0.6).
#' @param Bb A double indicating the smoothing factor in the time domain (default = 1).
#' @return An smoothened wavelet transform.
#' @export
WTSmoothing <- function(WT, frequencies, samplingfrequency = 1e3, sigma = 6.0, Ba = 0.6, Bb = 1) {
    .Call('_InVivoR_WTSmoothing', PACKAGE = 'InVivoR', WT, frequencies, samplingfrequency, sigma, Ba, Bb)
}

#' Smoothing complex wavelet matrix
#' 
#' This function computes the smoothened wavelet transform required 
#' for coherence calculation.
#' 
#' @param WT1 A complex matrix representing the wavelet transform.
#' @param WT2 A complex matrix representing the wavelet transform.
#' @param frequencies A vector indicating the frequencies which should be analysed.
#' @param samplingfrequency A double indicating the sampling frequency in Hz (default = 1000).
#' @param sigma A double indicating the shape parameter of the wavelet (default = 6).
#' @param Ba A double indicating the smoothing factor in the scale domain (default = 0.6).
#' @param Bb A double indicating the smoothing factor in the time domain (default = 1).
#' @return An smoothened wavelet transform.
#' @export
WTCoherence <- function(WT1, WT2, frequencies, samplingfrequency = 1000.0, sigma = 6.0, Ba = 0.6, Bb = 1) {
    .Call('_InVivoR_WTCoherence', PACKAGE = 'InVivoR', WT1, WT2, frequencies, samplingfrequency, sigma, Ba, Bb)
}

#' Maximum Amplitude Channel
#' 
#' This function uses the median spike shape to find channel with maximum amplitude.
#' As input the function requires the previously computed median spike matrix with dimensions of n.row = clusters and n.col = channel count
#'
#' @param median_input_mat A median matrix from arma_apply_median.
#' @return Returns a vector with position of maximum amplitude and amplitude itself.
#' @export
max_channel <- function(median_input_mat) {
    .Call('_InVivoR_max_channel', PACKAGE = 'InVivoR', median_input_mat)
}

#' Median Spike
#' 
#' This function uses an amplitude matrix from single spikes in channel.
#'
#' @param input_mat An input matrix with amplitudes for single spikes.
#' @return Returns a vector with length of concatenated samples.
#' @export
arma_apply_median <- function(input_mat) {
    .Call('_InVivoR_arma_apply_median', PACKAGE = 'InVivoR', input_mat)
}

#' Spike extraction loop
#' 
#' This function uses an amplitude matrix from single spikes in channel to output baseline corrected median spikes.
#'
#' @param input_mat_raw A numeric vector from a matrix with amplitudes for single spikes.
#' @param channel_nr An int indicating the number of recorded channels.
#' @return Returns a numeric spike vector with corrected baseline for single channels.
#' @export
arma_spike_extraction_loop <- function(input_mat_raw, channel_nr) {
    .Call('_InVivoR_arma_spike_extraction_loop', PACKAGE = 'InVivoR', input_mat_raw, channel_nr)
}

#' Maximum amplitude channel
#' 
#' This function takes a list of single events and computes the channel with max amplitude and amplitude for all units in list.
#'
#' @param spike_shape_list A numeric vector from a matrix with amplitudes for single spikes.
#' @param channel_nr An int indicating the number of recorded channels.
#' @return Returns a numeric matrix inlcuding the channel number and amplitude.
#' @export
chan_out <- function(spike_shape_list, channel_nr) {
    .Call('_InVivoR_chan_out', PACKAGE = 'InVivoR', spike_shape_list, channel_nr)
}

#' Butterworth filter
#' 
#' This function returns a modified FFT.
#'
#' @param InputFFT A complex matrix from FFTW.
#' @param SamplingFrequency A double indicating sampling frequency.
#' @param ORDER An int as filtering order (default = 2).
#' @param f0 A double as cutoff frequency.
#' @param type A string indicating the filter type ("low", "high"). The default is "low".
#' @param CORES An int indicating the number of threads used (default = 1).
#' @return Complex armadillo column vector.
#' @export
BWFilterCpp <- function(InputFFT, SamplingFrequency, ORDER = 2L, f0 = 10, type = "low", CORES = 1L) {
    .Call('_InVivoR_BWFilterCpp', PACKAGE = 'InVivoR', InputFFT, SamplingFrequency, ORDER, f0, type, CORES)
}

#' FIR filtering
#' 
#' This function applies an FIR filter to a signal an returns the filtered trace.
#'
#' @param SIGNAL A numeric vector.
#' @param FIR_FILTER A numeric vector which can be used as FIR filter.
#' @return Returns numeric vector which is the FIR filtered original signal.
#' @export
FirFiltering <- function(SIGNAL, FIR_FILTER) {
    .Call('_InVivoR_FirFiltering', PACKAGE = 'InVivoR', SIGNAL, FIR_FILTER)
}

#' Spike cross-correlation
#' 
#' This function computes the cross-correlation for spike trains.
#' In case of a cross-correlation of the same time series an
#' auto-correlation will be computed and with 0 correlation correction.
#'
#' @param x A numeric vector of times which has to be sorted in ascending order.
#' @param y A numeric vector of times which has to be sorted in ascending order.
#' @param WINDOW_LENGTH An int as total window length in seconds (default = 1).
#' @param BIN_SIZE A double indicating the size of bins in seconds (default = 0.001).
#' @return Integer vector with counts per bin.
#' @export
spike_ccf <- function(x, y, WINDOW_LENGTH = 1, BIN_SIZE = 0.001) {
    .Call('_InVivoR_spike_ccf', PACKAGE = 'InVivoR', x, y, WINDOW_LENGTH, BIN_SIZE)
}

#' Spike cross-correlation wrapper function for batch use 
#' 
#' Computes the confidence interval of a poisson train using an inverted gaussian
#' distribution. Based on the weighted average with the given distribution lamda
#' can be estimated. The confidence interval is then estimated by estimation through
#' Chisq-distribution.
#'
#' @param Time A numeric vector of times sorted in ascending order containing all time points.
#' @param UnitNr An integer vector containing the unit numbers in order of time occurence.
#' @param WINDOW_LENGTH An int as total window length in seconds (default = 1).
#' @param BIN_SIZE A double indicating the size of bins in seconds (default = 0.001).
#' @return Returns a list containing the unit number, the counts per bin and the random expected count.
#' @export
spike_ccf_batch <- function(Time, UnitNr, WINDOW_LENGTH = 1, BIN_SIZE = 0.001) {
    .Call('_InVivoR_spike_ccf_batch', PACKAGE = 'InVivoR', Time, UnitNr, WINDOW_LENGTH, BIN_SIZE)
}

#' Confidence interval for poisson train
#' 
#' Computes the confidence interval of a poisson train using an inverted gaussian
#' distribution. Based on the weighted average with the given distribution lamda
#' can be estimated. The confidence interval is then estimated by estimation through
#' Chisq-distribution.
#'
#' @param CountVector An integer vector of counts estimated by Spike CCF.
#' @param CONFLEVEL A double indicating the confidence-level (default = 0.95).
#' @param SD A double as standard deviation for a gaussian shape parameter (default = 0.6).
#' @param CENTREMIN A double as shape parameter determining the strength of centre exclusion (default = 0.6).
#' @param KERNELSIZE A double as length parameter for gaussian kernel (2*KERNELSIZE+1, default = 20).
#' @return Returns a list containing counts per bin, axis, random bin count, confidence-intervals with counts per bin.
#' @export
ConfIntPoisson <- function(CountVector, CONFLEVEL = 0.95, SD = 0.6, CENTREMIN = 0.6, KERNELSIZE = 20L) {
    .Call('_InVivoR_ConfIntPoisson', PACKAGE = 'InVivoR', CountVector, CONFLEVEL, SD, CENTREMIN, KERNELSIZE)
}

#' Spike cross-correlation wrapper function
#' 
#' This function computes the cross-correlation for spike trains.
#' In case of a cross-correlation of the same time series an auto-correlation 
#' will be computed and with 0 correlation correction.
#' The function has the capability to output the corresponding confidence-
#' interval based on an inverse gaussian lamda approximation. Further a random
#' distribution of spike occurence is computed based on spike number and time.
#'
#' @param x A numeric vector of times which has to be sorted in ascending order.
#' @param y A numeric vector of times which has to be sorted in ascending order.
#' @param WINDOW_LENGTH An int as total window length in seconds (default = 1).
#' @param BIN_SIZE A double indicating the size of bins in seconds (default = 0.001).
#' @param BaselineFrequency A bool to indicate whether base line activity should be estimated (default = TRUE).
#' @param ConfidenceInterval A bool to indicate whether confidence interval should be estimated (default = TRUE).
#' @param ConfLevel A double indicating the confidence-level (default = 0.95).
#' @param SD A double as standard deviation for a gaussian shape parameter (default = 0.6).
#' @param CENTREMIN A double as shape parameter determining the strength of centre exclusion (default = 0.6).
#' @param KERNELSIZE A double as length parameter for gaussian kernel (2*KERNELSIZE+1, default = 20).
#' @return Returns a list containing counts per bin, axis, random bin count, confidence-intervals with counts per bin.
#' @export
SpikeCCF <- function(x, y, WINDOW_LENGTH = 1, BIN_SIZE = 0.001, BaselineFrequency = TRUE, ConfidenceInterval = TRUE, ConfLevel = 0.95, SD = 0.6, CENTREMIN = 0.6, KERNELSIZE = 20L) {
    .Call('_InVivoR_SpikeCCF', PACKAGE = 'InVivoR', x, y, WINDOW_LENGTH, BIN_SIZE, BaselineFrequency, ConfidenceInterval, ConfLevel, SD, CENTREMIN, KERNELSIZE)
}

#' Spike stimulation properties
#' 
#' This function assigns stimulation properties to every spike so that it can be incorporated in a table.
#' 
#' @param spike_idx An integer vector representing the spike time point as sampling point (index).
#' @param stim_mat_org A matrix with stimulation properties (from Pulse_Seq_correctrion).
#' @param block_mat_org A matrix with stimulation block properties..
#' @param sampling_rate An integer indicating the sampling frequency.
#' @param include_isolated A bool indicting whether isolated stimulation outside of blocks should be included.
#' @return Returns a matrix with stimulation properties for every spike ("onset", "peak_loc_offset", "peak_amp", "stim_length", "phase", "pulse", "sine", "ramp_front", "ramp_end", "frequency", "burst stim", "pulse_nr_block", "pulse_nr", "stimulation_block", "stimulation_timing", "pre", "post", "hyper_block", "hyper_block_frequency").
#' @export
spike_stim_properties <- function(spike_idx, stim_mat_org, block_mat_org, sampling_rate, include_isolated) {
    .Call('_InVivoR_spike_stim_properties', PACKAGE = 'InVivoR', spike_idx, stim_mat_org, block_mat_org, sampling_rate, include_isolated)
}

#' Phase lock analysis
#' 
#' This function computes the phase lock using the Rho vector length 
#' (strength of the locking) and the circular mean phase from a list containing 
#' wavelet transforms of epochs. The input list has to be flattend (vectorised) 
#' first.
#' 
#' @param input_mat A matrix with time on the x-axis.
#' @param from_point A starting point for baseline used for z-score.
#' @param to_point An end point for baseline used for z-score.
#' @return Returns a matrix with z-scores based on baseline as reference.
#' @export
mat_baseline_zscore <- function(input_mat, from_point, to_point) {
    .Call('_InVivoR_mat_baseline_zscore', PACKAGE = 'InVivoR', input_mat, from_point, to_point)
}

