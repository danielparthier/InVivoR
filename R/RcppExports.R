# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Binary file access
#' 
#' This function extracts data points from a binary file based on time points and a window
#' which will cut out the data of and concatenates them based on the channels.
#' 
#' @param FILENAME A string as path to file with single "/".
#' @param spikePoints An integer vector for time points which correspond to sampling points.
#' @param WINDOW An integer indicating points taken before and after time point (default = 40).
#' @param CHANNELCOUNT An integer indicating number of channels in recording (default = 32).
#' @param CACHESIZE An integer indicating the size of cache used for buffering file in bytes (default = 512000).
#' @param BYTECODE An integer indicating number of bytes coding for bit rate (8bit = 1, 16bit = 2 etc.) (default = 2).
#' @return Returns an armadillo cube with extracted spikes.
#' @export
BinaryFileAccess <- function(FILENAME, spikePoints, WINDOW = 40L, CHANNELCOUNT = 32L, CACHESIZE = 512000L, BYTECODE = 2L) {
    .Call('_InVivoR_BinaryFileAccess', PACKAGE = 'InVivoR', FILENAME, spikePoints, WINDOW, CHANNELCOUNT, CACHESIZE, BYTECODE)
}

arma_gaussian <- function(sd, width, SamplingRateOut, SpikeTimings, StartTime, EndTime) {
    .Call('_InVivoR_arma_gaussian', PACKAGE = 'InVivoR', sd, width, SamplingRateOut, SpikeTimings, StartTime, EndTime)
}

arma_gaussian_kernel <- function(sd, width, SamplingRateOut) {
    .Call('_InVivoR_arma_gaussian_kernel', PACKAGE = 'InVivoR', sd, width, SamplingRateOut)
}

arma_gaussian_loop <- function(sd, SamplingRateOut, SpikeTimings, StartTime, EndTime) {
    .Call('_InVivoR_arma_gaussian_loop', PACKAGE = 'InVivoR', sd, SamplingRateOut, SpikeTimings, StartTime, EndTime)
}

BAKS <- function(SpikeTimings, Time, alpha, beta) {
    .Call('_InVivoR_BAKS', PACKAGE = 'InVivoR', SpikeTimings, Time, alpha, beta)
}

OKS <- function(SpikeTimings, Time, alpha, beta) {
    .Call('_InVivoR_OKS', PACKAGE = 'InVivoR', SpikeTimings, Time, alpha, beta)
}

BAKS_fast <- function(SpikeTimings, Time, alpha, beta) {
    .Call('_InVivoR_BAKS_fast', PACKAGE = 'InVivoR', SpikeTimings, Time, alpha, beta)
}

BAKS_fast_new <- function(SpikeTimings, Time, alpha, beta) {
    .Call('_InVivoR_BAKS_fast_new', PACKAGE = 'InVivoR', SpikeTimings, Time, alpha, beta)
}

#' @useDynLib InVivoR
#' @importFrom Rcpp sourceCpp
NULL

#' Modulation index analysis
#' 
#' This function returns a list including a modulation index matrix, the phase frequency and the power frequency.
#' there are leading NA, marking the leadings NA as TRUE and
#' everything else as FALSE.
#'
#' @param PowerMatRaw A matrix with power.
#' @param PhaseMatRaw A matrix with phase.
#' @param PowerPeriods A double vector with unique periods (1/Frequency) for power matrix.
#' @param PhasePeriods A double vector with unique periods (1/Frequency) for phase matrix.
#' @param BIN_NUMBER An integer indicating in how many parts phase should be split.
#' @param PHASE_FREQ_START A double indicating starting frequency (1/period) for phase.
#' @param PHASE_FREQ_END A double indicating end frequency (1/period) for phase.
#' @param POWER_FREQ_START A double indicating starting frequency (1/period) for power.
#' @param POWER_FREQ_END A A double indicating end frequency (1/period) for power.
#' @param CORES An integer indicating number of threads used (multicore support).
#' @return Returns a list containing the modulation index matrix and vectors containing its axis (Powerfrequency and Phasefrequency)
#' @export
MI <- function(PowerMatRaw, PhaseMatRaw, PowerPeriods, PhasePeriods, BIN_NUMBER, PHASE_FREQ_START, PHASE_FREQ_END, POWER_FREQ_START, POWER_FREQ_END, CORES) {
    .Call('_InVivoR_MI', PACKAGE = 'InVivoR', PowerMatRaw, PhaseMatRaw, PowerPeriods, PhasePeriods, BIN_NUMBER, PHASE_FREQ_START, PHASE_FREQ_END, POWER_FREQ_START, POWER_FREQ_END, CORES)
}

#' Phase lock analysis
#' 
#' This function computes the phase lock using the Rho vector length 
#' (strength of the locking) and the circular mean phase from a list containing 
#' wavelet transforms of epochs. The input list has to be flattend (vectorised) 
#' first.
#' 
#' @param x A numeric vector of phases (radians).
#' @param DIM_X An int for x-dimension of wavelet transform.
#' @param DIM_Y An int for y-dimension of wavelet transform.
#' @param DIM_Z An int for z-dimension of list (number of epochs).
#' @param CORES An int indicating the number of threads used (default = 1).
#' @return Returns a list containing a matrix with Rho vector lengths and a matrix with the corresponding circular mean.
#' @export
PhaseListAnalysis <- function(x, DIM_X, DIM_Y, DIM_Z, CORES = 1L) {
    .Call('_InVivoR_PhaseListAnalysis', PACKAGE = 'InVivoR', x, DIM_X, DIM_Y, DIM_Z, CORES)
}

#' Matrix shuffle
#' 
#' This function shuffles the data independently of dimensions without 
#' resampling from a input matrix. It returns the probability for a any 
#' given value in a matrix to be larger than a random sample.
#' 
#' @param x A matrix.
#' @param DIM_X An int for x-dimension of matrix.
#' @param DIM_Y An int for y-dimension of matrix.
#' @param SHUFFLES An int indicating the number of shuffles.
#' @param CORES An int indicating the number of threads used (default = 1).
#' @return Returns a matrix indicating the probability of value being larger than shuffled data.
#' @export
PhaseListAnalysisShuffle <- function(x, DIM_X, DIM_Y, SHUFFLES, CORES) {
    .Call('_InVivoR_PhaseListAnalysisShuffle', PACKAGE = 'InVivoR', x, DIM_X, DIM_Y, SHUFFLES, CORES)
}

#' Matrix resample
#' 
#' This function shuffles the data independently of dimensions with 
#' resampling from a input matrix. It returns the probability for a any 
#' given value in a matrix to be larger than a random sample.
#' 
#' @param x A matrix.
#' @param DIM_X An int for x-dimension of matrix.
#' @param DIM_Y An int for y-dimension of matrix.
#' @param SHUFFLES An int indicating the number of shuffles.
#' @param CORES An int indicating the number of threads used (default = 1).
#' @return Returns a matrix indicating the probability of value being larger than shuffled data.
#' @export
PhaseListAnalysisResample <- function(x, DIM_X, DIM_Y, SHUFFLES, CORES) {
    .Call('_InVivoR_PhaseListAnalysisResample', PACKAGE = 'InVivoR', x, DIM_X, DIM_Y, SHUFFLES, CORES)
}

#' Maximum Amplitude Channel
#' 
#' This function uses the median spike shape to find channel with maximum amplitude.
#' As input the function requires the previously computed median spike matrix with dimensions of n.row = clusters and n.col = channel count
#'
#' @param median_input_mat A median matrix from arma_apply_median.
#' @return Returns a vector with position of maximum amplitude and amplitude itself.
#' @export
max_channel <- function(median_input_mat) {
    .Call('_InVivoR_max_channel', PACKAGE = 'InVivoR', median_input_mat)
}

#' Median Spike
#' 
#' This function uses an amplitude matrix from single spikes in channel.
#'
#' @param input_mat An input matrix with amplitudes for single spikes.
#' @return Returns a vector with length of concatenated samples.
#' @export
arma_apply_median <- function(input_mat) {
    .Call('_InVivoR_arma_apply_median', PACKAGE = 'InVivoR', input_mat)
}

#' Spike extraction loop
#' 
#' This function uses an amplitude matrix from single spikes in channel to output baseline corrected median spikes.
#'
#' @param input_mat_raw A numeric vector from a matrix with amplitudes for single spikes.
#' @param channel_nr An int indicating the number of recorded channels.
#' @return Returns a numeric spike vector with corrected baseline for single channels.
#' @export
arma_spike_extraction_loop <- function(input_mat_raw, channel_nr) {
    .Call('_InVivoR_arma_spike_extraction_loop', PACKAGE = 'InVivoR', input_mat_raw, channel_nr)
}

#' Maximum amplitude channel
#' 
#' This function takes a list of single events and computes the channel with max amplitude and amplitude for all units in list.
#'
#' @param spike_shape_list A numeric vector from a matrix with amplitudes for single spikes.
#' @param channel_nr An int indicating the number of recorded channels.
#' @return Returns a numeric matrix inlcuding the channel number and amplitude.
#' @export
chan_out <- function(spike_shape_list, channel_nr) {
    .Call('_InVivoR_chan_out', PACKAGE = 'InVivoR', spike_shape_list, channel_nr)
}

#' Butterworth filter
#' 
#' This function returns a modified FFT.
#'
#' @param InputFFT A complex matrix from FFTW.
#' @param SamplingFrequency A double indicating sampling frequency.
#' @param ORDER An int as filtering order (default = 2).
#' @param f0 A double as cutoff frequency.
#' @param type A string indicating the filter type ("low", "high"). The default is "low".
#' @param CORES An int indicating the number of threads used (default = 1).
#' @return Complex armadillo column vector.
#' @export
BWFilter <- function(InputFFT, SamplingFrequency, ORDER = 2L, f0 = 10, type = "low", CORES = 1L) {
    .Call('_InVivoR_BWFilter', PACKAGE = 'InVivoR', InputFFT, SamplingFrequency, ORDER, f0, type, CORES)
}

#' FIR filtering
#' 
#' This function applies an FIR filter to a signal an returns the filtered trace.
#'
#' @param SIGNAL A numeric vector.
#' @param FIR_FILTER A numeric vector which can be used as FIR filter.
#' @return Returns numeric vector which is the FIR filtered original signal.
#' @export
FirFiltering <- function(SIGNAL, FIR_FILTER) {
    .Call('_InVivoR_FirFiltering', PACKAGE = 'InVivoR', SIGNAL, FIR_FILTER)
}

#' Spike cross-correlation
#' 
#' This function computes the cross-correlation for spike trains.
#' In case of a cross-correlation of the same time series an
#' auto-correlation will be computed and with 0 correlation correction.
#'
#' @param x A numeric vector of times which has to be sorted in ascending order.
#' @param y A numeric vector of times which has to be sorted in ascending order.
#' @param WINDOW_LENGTH An int as filtering order (default = 2).
#' @param BIN_SIZE A double as cutoff frequency.
#' @return Integer vector with counts per bin.
#' @export
spike_ccf <- function(x, y, WINDOW_LENGTH, BIN_SIZE) {
    .Call('_InVivoR_spike_ccf', PACKAGE = 'InVivoR', x, y, WINDOW_LENGTH, BIN_SIZE)
}

#' Spike cross-correlation wrapper function for batch use 
#' 
#' Computes the confidence interval of a poisson train using an inverted gaussian
#' distribution. Based on the weighted average with the given distribution lamda
#' can be estimated. The confidence interval is then estimated by estimation through
#' Chisq-distribution.
#'
#' @param Time A numeric vector of times sorted in ascending order containing all time points.
#' @param UnitNr An integer vector containing the unit numbers in order of time occurence.
#' @param WINDOW_LENGTH A double as shape parameter determining the strength of centre exclusion.
#' @param BIN_SIZE A double as length parameter for gaussian kernel (2*KERNELSIZE+1).
#' @return Returns a list containing the unit number, the counts per bin and the random expected count.
#' @export
spike_ccf_batch <- function(Time, UnitNr, WINDOW_LENGTH, BIN_SIZE) {
    .Call('_InVivoR_spike_ccf_batch', PACKAGE = 'InVivoR', Time, UnitNr, WINDOW_LENGTH, BIN_SIZE)
}

#' Confidence interval for poisson train
#' 
#' Computes the confidence interval of a poisson train using an inverted gaussian
#' distribution. Based on the weighted average with the given distribution lamda
#' can be estimated. The confidence interval is then estimated by estimation through
#' Chisq-distribution.
#'
#' @param CountVector An integer vector of counts estimated by Spike CCF.
#' @param CONFLEVEL A double indicating the confidence-level (default = 0.95).
#' @param SD A double as standard deviation for a gaussian shape parameter (default = 0.6).
#' @param CENTREMIN A double as shape parameter determining the strength of centre exclusion.
#' @param KERNELSIZE A double as length parameter for gaussian kernel (2*KERNELSIZE+1).
#' @return Returns a list containing counts per bin, axis, random bin count, confidence-intervals with counts per bin.
#' @export
ConfIntPoisson <- function(CountVector, CONFLEVEL = 0.95, SD = 0.6, CENTREMIN = 0.6, KERNELSIZE = 20L) {
    .Call('_InVivoR_ConfIntPoisson', PACKAGE = 'InVivoR', CountVector, CONFLEVEL, SD, CENTREMIN, KERNELSIZE)
}

#' Spike cross-correlation wrapper function
#' 
#' This function computes the cross-correlation for spike trains.
#' In case of a cross-correlation of the same time series an auto-correlation 
#' will be computed and with 0 correlation correction.
#' The function has the capability to output the corresponding confidence-
#' interval based on an inverse gaussian lamda approximation. Further a random
#' distribution of spike occurence is computed based on spike number and time.
#'
#' @param x A numeric vector of times which has to be sorted in ascending order.
#' @param y A numeric vector of times which has to be sorted in ascending order.
#' @param WINDOW_LENGTH An int as filtering order (default = 2).
#' @param BIN_SIZE A double as cutoff frequency.
#' @return Returns a list containing counts per bin, axis, random bin count, confidence-intervals with counts per bin.
#' @export
SpikeCCF <- function(x, y, WINDOW_LENGTH = 1, BIN_SIZE = 0.001, BaselineFrequency = TRUE, ConfidenceInterval = TRUE, ConfLevel = 0.95, SD = 0.6, CENTREMIN = 0.6, KERNELSIZE = 20L) {
    .Call('_InVivoR_SpikeCCF', PACKAGE = 'InVivoR', x, y, WINDOW_LENGTH, BIN_SIZE, BaselineFrequency, ConfidenceInterval, ConfLevel, SD, CENTREMIN, KERNELSIZE)
}

#' Spike stimulation properties
#' 
#' This function assigns stimulation properties to every spike so that it can be incorporated in a table.
#' 
#' @param spike_idx An integer vector representing the spike time point as sampling point (index).
#' @param stim_mat_org A matrix with stimulation properties (from Pulse_Seq_correctrion).
#' @param block_mat_org A matrix with stimulation block properties..
#' @param sampling_rate An integer indicating the sampling frequency.
#' @param include_isolated A bool indicting whether isolated stimulation outside of blocks should be included.
#' @return Returns a matrix with stimulation properties for every spike ("onset", "peak_loc_offset", "peak_amp", "stim_length", "phase", "pulse", "sine", "ramp_front", "ramp_end", "frequency", "burst stim", "pulse_nr_block", "pulse_nr", "stimulation_block", "stimulation_timing", "pre", "post", "hyper_block", "hyper_block_frequency").
#' @export
spike_stim_properties <- function(spike_idx, stim_mat_org, block_mat_org, sampling_rate, include_isolated) {
    .Call('_InVivoR_spike_stim_properties', PACKAGE = 'InVivoR', spike_idx, stim_mat_org, block_mat_org, sampling_rate, include_isolated)
}

#' Phase lock analysis
#' 
#' This function computes the phase lock using the Rho vector length 
#' (strength of the locking) and the circular mean phase from a list containing 
#' wavelet transforms of epochs. The input list has to be flattend (vectorised) 
#' first.
#' 
#' @param input_mat A matrix with time on the x-axis.
#' @param from_point A starting point for baseline used for z-score.
#' @param to_point An end point for baseline used for z-score.
#' @return Returns a matrix with z-scores based on baseline as reference.
#' @export
mat_baseline_zscore <- function(input_mat, from_point, to_point) {
    .Call('_InVivoR_mat_baseline_zscore', PACKAGE = 'InVivoR', input_mat, from_point, to_point)
}

