# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Binary file access
#' 
#' This function extracts data points from a binary file based on time points and a window
#' which will cut out the data of and concatenates them based on the channels.
#' 
#' @param FILENAME A string as path to file with single "/".
#' @param spikePoints An integer vector for time points which correspond to sampling points.
#' @param WINDOW An integer indicating points taken before and after time point (default = 40).
#' @param CHANNELCOUNT An integer indicating number of channels in recording (default = 32).
#' @param CACHESIZE An integer indicating the size of cache used for buffering file in bytes (default = 512000).
#' @param BYTECODE An integer indicating number of bytes coding for bit rate (8bit = 1, 16bit = 2 etc.) (default = 2).
#' @return Returns an armadillo cube with extracted spikes.
#' @export
BinaryFileAccess <- function(FILENAME, spikePoints, WINDOW = 40L, CHANNELCOUNT = 32L, CACHESIZE = 51200L, BYTECODE = 2L) {
    .Call('_InVivoR_BinaryFileAccess', PACKAGE = 'InVivoR', FILENAME, spikePoints, WINDOW, CHANNELCOUNT, CACHESIZE, BYTECODE)
}

#' Load stimulation file
#' 
#' This function extracts data points from a binary file either the analogin.dat or digitalin.dat generated intan system.
#' 
#' @param FILENAME A string as path to file with single "/".
#' @param digital A bool indicating whether the file is a digital or analogin input (default = false).
#' @return Returns an armadillo cube with extracted spikes.
#' @export
StimFileRead <- function(FILENAME, digital = FALSE) {
    .Call('_InVivoR_StimFileRead', PACKAGE = 'InVivoR', FILENAME, digital)
}

#' Load amplifier amplitude file
#' 
#' This function extracts data points from a binary file (amplifier.dat) generated by the intan system.
#' 
#' @param FILENAME A string as path to file with single "/".
#' @param ChannelNumber An integer indicating number of channels in recording (default = 32).
#' @return Returns an armadillo matrix (rows = ChannelNumber, columns = time).
#' @export
AmpFileRead <- function(FILENAME, ChannelNumber = 32L) {
    .Call('_InVivoR_AmpFileRead', PACKAGE = 'InVivoR', FILENAME, ChannelNumber)
}

AmpFileReadMerge <- function(FILENAME1, FILENAME2, ChannelNumber = 32L) {
    .Call('_InVivoR_AmpFileReadMerge', PACKAGE = 'InVivoR', FILENAME1, FILENAME2, ChannelNumber)
}

convertToBinary <- function(x) {
    .Call('_InVivoR_convertToBinary', PACKAGE = 'InVivoR', x)
}

#' Decimate
#' 
#' This function downsamples a signal using a preset FIR filter which should be filtering at half the target frequency.
#'
#' @param SIGNAL A numeric vector with length N.
#' @param FIR_FILTER A predefined FIR filter as numeric vector (low-pass filter for <= target frequency).
#' @param M An int representing downsampling factor.
#' @return Returns a numeric vector with length N/M.
#' @export
decimate <- function(SIGNAL, FIR_FILTER, M) {
    .Call('_InVivoR_decimate', PACKAGE = 'InVivoR', SIGNAL, FIR_FILTER, M)
}

#' ERP (event-related potential) extraction
#' 
#' This function returns a matrix with extracted traces for any given range. 
#' The range is has to be provided in form of onset indeces and end indeces. 
#' Additional information can be provided to adjust for sampling differences 
#' between range points and trace sampling frequency. If required the window 
#' is proportionally elongated to include Pre/Post times.
#'
#' @param Trace A numeric vector which is used for extraction.
#' @param Onset An integer vector with onset sample indeces.
#' @param End An integer vector with end sample indeces.
#' @param SamplingFreqStim A double indicating the sampling frequency of onset/end indeces.
#' @param SamplingFreqTrace A double indicating the sampling frequency of the trace.
#' @param PrePhase A bool indicating if pre-onset timings should be included (default = false).
#' @param PostPhase A bool indicating if post-end timings should be included (default = false).
#' @return Returns a matrix with extracted ERPs.
#' @export
ERPMat <- function(Trace, Onset, End, SamplingFreqStim = 0, SamplingFreqTrace = 0, PrePhase = FALSE, PostPhase = FALSE) {
    .Call('_InVivoR_ERPMat', PACKAGE = 'InVivoR', Trace, Onset, End, SamplingFreqStim, SamplingFreqTrace, PrePhase, PostPhase)
}

#' Wrapper for ERP (event-related potential) extraction
#' 
#' This function returns a list which includes the frequencies and matrices 
#' with extracted traces for any given range. The range is has to be provided
#' in form of onset indeces and end indeces. Additional information can be 
#' provided to adjust for sampling differences between range points and trace 
#' sampling frequency. If required the window is proportionally elongated to 
#' include Pre/Post times.
#'
#' @param Trace A numeric vector which is used for extraction.
#' @param BlockMat The stimulation block matrix from StimulusSequence() including onset and end timings.
#' @param SamplingFreqStim A double indicating the sampling frequency of onset/end indeces.
#' @param SamplingFreqTrace A double indicating the sampling frequency of the trace.
#' @param PrePhase A bool indicating if pre-onset timings should be included (default = true).
#' @param PostPhase A bool indicating if post-end timings should be included (default = true).
#' @param FixStartLength A double indicating the starting length when fixed window is used (default = 0).
#' @param WindowLength A double indicating the time block in seconds (default = 0).
#' @return Returns a list which includes stimulation frequencies for hyperblocks and the corresponding ERP matrices.
#' @export
ERPList <- function(Trace, BlockMat, SamplingFreqStim = 0, SamplingFreqTrace = 0, PrePhase = TRUE, PostPhase = TRUE, FixStartLength = 0, WindowLength = 0) {
    .Call('_InVivoR_ERPList', PACKAGE = 'InVivoR', Trace, BlockMat, SamplingFreqStim, SamplingFreqTrace, PrePhase, PostPhase, FixStartLength, WindowLength)
}

#' ERP (event-related potential) extraction
#' 
#' This function returns a matrix with extracted traces for any given range. 
#' The range is has to be provided in form of onset indeces and end indeces. 
#' Additional information can be provided to adjust for sampling differences 
#' between range points and trace sampling frequency. If required the window 
#' is proportionally elongated to include Pre/Post times.
#'
#' @param SpikeTimes A numeric vector with spike times in seconds.
#' @param timeStart A double for the start time for which the rate should be computed.
#' @param timeEnd A double for the end time for which the rate should be computed.
#' @param sigma A double indicating sigma of the gausian kernel in seconds.
#' @param alpha A double indicating alpha of the gamma kernel in seconds.
#' @param useBAKS A indicating whether Bayesian Adaptive Kernel Smoother should be used.
#' @param BAKSalpha A double indicating the prior for alpha in BAKS (default = 4).
#' @param BAKSbeta A double indicating the prior for beta in BAKS (default = 4).
#' @param SamplingRate A double indicating the sampling rate (default = 1000).
#' @param CORES An integer indicating how many core should be used (default = 4).
#' @return Returns a vector with firing rate.
#' @export
FiringRate <- function(SpikeTimes, timeStart = NULL, timeEnd = NULL, sigma = NULL, alpha = NULL, useBAKS = FALSE, BAKSalpha = 4, BAKSbeta = 4, SamplingRate = 1e3, CORES = 4L) {
    .Call('_InVivoR_FiringRate', PACKAGE = 'InVivoR', SpikeTimes, timeStart, timeEnd, sigma, alpha, useBAKS, BAKSalpha, BAKSbeta, SamplingRate, CORES)
}

FiringRateSparse <- function(SpikeTimes, sigma = NULL, alpha = NULL, SamplingRate = 1e3) {
    .Call('_InVivoR_FiringRateSparse', PACKAGE = 'InVivoR', SpikeTimes, sigma, alpha, SamplingRate)
}

#' @useDynLib InVivoR
#' @importFrom Rcpp sourceCpp
NULL

#' Modulation index analysis
#' 
#' This function returns a list including a modulation index matrix, the phase frequency and the power frequency.
#' there are leading NA, marking the leadings NA as TRUE and
#' everything else as FALSE.
#'
#' @param PowerMatRaw A matrix with power.
#' @param PhaseMatRaw A matrix with phase.
#' @param PowerPeriods A double vector with unique periods (1/Frequency) for power matrix.
#' @param PhasePeriods A double vector with unique periods (1/Frequency) for phase matrix.
#' @param BIN_NUMBER An integer indicating in how many parts phase should be split.
#' @param PHASE_FREQ_START A double indicating starting frequency (1/period) for phase.
#' @param PHASE_FREQ_END A double indicating end frequency (1/period) for phase.
#' @param POWER_FREQ_START A double indicating starting frequency (1/period) for power.
#' @param POWER_FREQ_END A A double indicating end frequency (1/period) for power.
#' @param CORES An integer indicating number of threads used (multicore support).
#' @return Returns a list containing the modulation index matrix and vectors containing its axis (Powerfrequency and Phasefrequency)
#' @export
MI <- function(PowerMatRaw, PhaseMatRaw, PowerPeriods, PhasePeriods, BIN_NUMBER, PHASE_FREQ_START, PHASE_FREQ_END, POWER_FREQ_START, POWER_FREQ_END, CORES) {
    .Call('_InVivoR_MI', PACKAGE = 'InVivoR', PowerMatRaw, PhaseMatRaw, PowerPeriods, PhasePeriods, BIN_NUMBER, PHASE_FREQ_START, PHASE_FREQ_END, POWER_FREQ_START, POWER_FREQ_END, CORES)
}

#' FIR filtering
#' 
#' This function applies an FIR filter to a signal an returns the filtered trace.
#'
#' @param SIGNAL A numeric vector.
#' @param FIR_FILTER A numeric vector which can be used as FIR filter.
#' @param FiltFilt A bool indicating if "filtfilt" mode should be used.
#' @param BatchSize An integer indicating the starting batchsize of the trace (chunk size will be optimised for FFT).
#' @param CORES An integer indicating what number of cores should be used.
#' @return Returns numeric vector which is the FIR filtered original signal.
#' @export
FirFilteringOverlap <- function(SIGNAL, FIR_FILTER, FiltFilt = TRUE, BatchSize = 1e4L, CORES = 1L) {
    .Call('_InVivoR_FirFilteringOverlap', PACKAGE = 'InVivoR', SIGNAL, FIR_FILTER, FiltFilt, BatchSize, CORES)
}

#' Butterworth filter c++
#' 
#' This function returns a filtered Signal.
#'
#' @param InputSignal A complex matrix from FFTW.
#' @param SamplingFrequency A double indicating sampling frequency.
#' @param ORDER An int as filtering order (default = 2).
#' @param f0 A double as cutoff frequency (default = 10).
#' @param type A string indicating the filter type ("low", "high"). The default is "low".
#' @param BatchSize An integer indicating the batch size for FFT (default = 4e4).
#' @param CORES An int indicating the number of threads used (default = 1).
#' @return Filtered signal as numeric vector.
#' @export
BWFiltCppOverlap <- function(InputSignal, SamplingFrequency, ORDER = 2L, f0 = 10, type = "low", BatchSize = 4e4L, CORES = 1L) {
    .Call('_InVivoR_BWFiltCppOverlap', PACKAGE = 'InVivoR', InputSignal, SamplingFrequency, ORDER, f0, type, BatchSize, CORES)
}

#' Phase lock analysis
#' 
#' This function computes the phase lock using the Rho vector length 
#' (strength of the locking) and the circular mean phase from a cube containing 
#' wavelet transforms of epochs.
#' 
#' @param x A cube of phases (radians) with slices as different ERPs.
#' @param CORES An int indicating the number of threads used (default = 1).
#' @return Returns a list containing a matrix with Rho vector lengths and a matrix with the corresponding circular mean.
#' @export
PhaseListAnalysis <- function(x, CORES = 1L) {
    .Call('_InVivoR_PhaseListAnalysis', PACKAGE = 'InVivoR', x, CORES)
}

#' Matrix shuffle
#' 
#' This function shuffles the data independently of dimensions without 
#' resampling from a input matrix. It returns the probability for a any 
#' given value in a matrix to be larger than a random sample.
#' 
#' @param x A matrix.
#' @param SHUFFLES An int indicating the number of shuffles.
#' @param CORES An int indicating the number of threads used (default = 1).
#' @return Returns a matrix indicating the probability of value being larger than shuffled data.
#' @export
PhaseListAnalysisShuffle <- function(x, SHUFFLES = 200L, CORES = 1L) {
    .Call('_InVivoR_PhaseListAnalysisShuffle', PACKAGE = 'InVivoR', x, SHUFFLES, CORES)
}

#' Matrix resample
#' 
#' This function shuffles the data independently of dimensions with 
#' resampling from a input matrix. It returns the probability for a any 
#' given value in a matrix to be larger than a random sample.
#' 
#' @param x A matrix.
#' @param SHUFFLES An int indicating the number of shuffles.
#' @param CORES An int indicating the number of threads used (default = 1).
#' @return Returns a matrix indicating the probability of value being larger than shuffled data.
#' @export
PhaseListAnalysisResample <- function(x, SHUFFLES = 200L, CORES = 1L) {
    .Call('_InVivoR_PhaseListAnalysisResample', PACKAGE = 'InVivoR', x, SHUFFLES, CORES)
}

#' Butterworth filter c++
#' 
#' This function returns a filtered Signal.
#'
#' @param InputSignal A complex matrix from FFTW.
#' @param SamplingFrequency A double indicating sampling frequency.
#' @param ORDER An int as filtering order (default = 2).
#' @param f0 A double as cutoff frequency (default = 10).
#' @param type A string indicating the filter type ("low", "high"). The default is "low".
#' @param BatchSize An integer indicating the batch size for FFT (default = 4e4).
#' @param CORES An int indicating the number of threads used (default = 1).
#' @return Filtered signal as numeric vector.
#' @export
BWFiltCpp <- function(InputSignal, SamplingFrequency, ORDER = 2L, f0 = 1000, type = "low", BatchSize = 4e4L, CORES = 1L) {
    .Call('_InVivoR_BWFiltCpp', PACKAGE = 'InVivoR', InputSignal, SamplingFrequency, ORDER, f0, type, BatchSize, CORES)
}

#' Stimulus sequence
#' 
#' This function analyses stimulus time series and extracts features which 
#' are returned in a list. Part of the output is the single stimulus feature
#' and the second part is a stimulus block summary.
#'
#' @param raw A numeric vector which is the stimulation over time as continues series.
#' @param sampling_frequency An integer indicating the sampling frequency.
#' @param threshold A double indicating the threshold of stimulus detection.
#' @param max_time_gap A double indicating the maximum time between blocks.
#' @return Returns a list with a matrix showing single pulse properperties and a matrix with block properties.
#' @export
StimulusSequence <- function(raw, sampling_frequency, threshold, max_time_gap, CORES = 1L) {
    .Call('_InVivoR_StimulusSequence', PACKAGE = 'InVivoR', raw, sampling_frequency, threshold, max_time_gap, CORES)
}

#' Morlet wavelet (time domain)
#' 
#' This function returns a complex morlet wavelet in the time domain. It can be 
#' used for convolution.
#'
#' @param t A numeric sequence of time (-t/2 to t/2) with steps of sampling frequency.
#' @param sigma A double indicating the shape parameter of the wavelet.
#' @return Morlet wavelet as complex vector.
NULL

#' Morlet wavelet (frequency domain)
#' 
#' This function returns a morlet wavelet in the frequency domain. It can be 
#' used for implementation via inverse FFT.
#'
#' @param angFreq A numeric sequence of angular frequency (0 to 2pi).
#' @param sigma A double indicating the shape parameter of the wavelet.
#' @return Morlet wavelet as numeric vector.
NULL

#' 
#' @param SignalFFT A complex vector of the signal FFT.
#' @param scale A double indicating the scale parameter of daughter wavelet.
#' @param morletFFT A vector of wavelet in frequency domain.
#' @param LNorm A double indicating the L normalisation (power of 1/LNorm, default = 2).
#' @return Morlet wavelet as numeric vector.
NULL

#' Wavelet transform
#' 
#' This function performs a wavelet transform of a signal for different scales 
#' and returns a complex matrix from the convolution with a complex wavelet in 
#' the frequency domain.
#' 
#' @param Signal A numeric vector.
#' @param frequencies A vector indicating the frequencies which should be analysed.
#' @param samplingfrequency A double indicating the sampling frequency in Hz (default = 1000).
#' @param sigma A double indicating the shape parameter of the wavelet (default = 6).
#' @param LNorm A double indicating the L normalisation (power of 1/LNorm, default = 2).
#' @param CORES An integer indicating number of threads used (default = 1). 
#' @return Wavelet transform as complex matrix.
#' 
#' @examples # test signal
#' testSignal <- sin(seq(0,32*pi, length.out = 4000))*6
#' testSignal <- testSignal+sin(seq(0,84*pi, length.out = 4000))*10
#' 
#' # apply wavelet tranform
#' WTmat <- WT(Signal = testSignal, frequencies = seq(from = 0.2,to = 20, by = 0.1),
#' samplingfrequency = 1e3, sigma = 12, LNorm = 2, CORES = 1)
#' 
#' # plot real part of WT
#' image(x = Re(WTmat), col = hcl.colors(n = 1000), useRaster = TRUE)
#' 
#' # plot power of WT
#' image(x = abs(WTmat)^2, col = hcl.colors(n = 1000), useRaster = TRUE)
#' 
#' # plot phase
#' image(x = atan2(y = Im(WTmat), x = Re(WTmat)),
#'       col = hcl.colors(n = 1000),
#'       useRaster = TRUE)
#' 
#' @export
WT <- function(Signal, frequencies, samplingfrequency = 1e3, sigma = 6, LNorm = 2, CORES = 1L) {
    .Call('_InVivoR_WT', PACKAGE = 'InVivoR', Signal, frequencies, samplingfrequency, sigma, LNorm, CORES)
}

#' Wavelet transform (from ERP matrix)
#' 
#' This function performs a wavelet transform of a signal for different scales 
#' and returns a complex matrix from the convolution with a complex wavelet in 
#' the frequency domain.
#' 
#' @param ERPMat A numeric matrix with rows for ERP signals and columns as time domain.
#' @param frequencies A vector indicating the frequencies which should be analysed.
#' @param samplingfrequency A double indicating the sampling frequency in Hz (default = 1000).
#' @param sigma A double indicating the shape parameter of the wavelet (default = 6).
#' @param LNorm A double indicating the L normalisation (power of 1/LNorm, default = 2).
#' @param CORES An integer indicating number of threads used (default = 1).
#' @param compression An integer indicating number of threads used (default = 1).
#' @param PhaseAnalysis An integer indicating number of threads used (default = 1) 
#' @return List with wavelet transform as complex cube (each slice is from one ERP or when compressed one matrix), 
#' rho vector length and mean phase.
#' 
#' @examples # Generate test signal
#' testSignal <- sin(seq(0,32*pi, length.out = 4000))*6
#' testSignal <- testSignal+sin(seq(0,84*pi, length.out = 4000))*10
#' 
#' # Generate ERP matrix
#' ERPmat <- ERPMat(Trace = testSignal, Onset = (1:10)*200, End = (1:10)*400)
#'   
#' # Apply WT to all ERPs
#' WTCube <- WTbatch(ERPMat = ERPmat,
#'                   frequencies = seq(0.2,20, 0.2),
#'                   samplingfrequency = 1000,
#'                   sigma = 6, LNorm = 2,
#'                   CORES = 1,
#'                   compression = TRUE,
#'                   PhaseAnalysis = TRUE)
#'     
#' # Cube dimensions
#' length(WTCube)
#' dim(WTCube[[1]])
#'       
#' # Real part of wavelet transform for different ERPs
#' image(x = abs(WTCube$Raw)^2, col = hcl.colors(n = 1000), useRaster = TRUE)
#' image(x = WTCube$Rho, col = hcl.colors(n = 1000), useRaster = TRUE, zlim = c(0,1))
#' image(x = WTCube$Mean, col = hcl.colors(n = 1000), useRaster = TRUE)
#' 
#' @export
WTbatch <- function(ERPMat, frequencies, samplingfrequency = 1e3, sigma = 6, LNorm = 2, CORES = 1L, compression = FALSE, PhaseAnalysis = FALSE) {
    .Call('_InVivoR_WTbatch', PACKAGE = 'InVivoR', ERPMat, frequencies, samplingfrequency, sigma, LNorm, CORES, compression, PhaseAnalysis)
}

#' Wavelet power matrix (from wavelet power cube)
#' 
#' This function computes the average power of several WT which can be returned as raw power
#' or as z-score. If the z-score is returned then every slice of the cube is z-transformed 
#' independently and the average is calculated in z-direction.
#' 
#' @param x A cube with power matrices each slice representing ERP.
#' @param ZScore A bool indicating if Z-score should be computed.
#' @return An average power matrix (raw or as z-score).
#' @export
PowerMat <- function(x, ZScore = FALSE) {
    .Call('_InVivoR_PowerMat', PACKAGE = 'InVivoR', x, ZScore)
}

#' Synchrosqueezed wavelet power matrix (from wavelet power matrix)
#' 
#' This function computes the synchrosqueezed wavelet transform as proposed by Daubechies and Maes (1996). Wavelet 
#' coefficients of the wavelet will be reassigned according to the instantaneous frequency in the transform.
#' 
#' @param WT A complex matrix representing the wavelet transform.
#' @param frequencies A vector indicating the frequencies which should be analysed.
#' @param samplingfrequency A double indicating the sampling frequency in Hz (default = 1000).
#' @param sigma A double indicating the shape parameter of the wavelet (default = 6).
#' @param CORES An integer indicating number of threads used (default = 1). 
#' @return A complex matrix representing the synchrosqueezed wavelet transform.
#' 
#' @export
WTSqueeze <- function(WT, frequencies, samplingfrequency = 1e3, sigma = 6, CORES = 1L) {
    .Call('_InVivoR_WTSqueeze', PACKAGE = 'InVivoR', WT, frequencies, samplingfrequency, sigma, CORES)
}

#' Average complex matrix (from wavelet power cube)
#' 
#' This function computes the average complex matrix of a complex cube.
#' 
#' @param x A cube with complex matrices each slice representing ERP.
#' @return An average complex matrix.
#' 
#' @export
CxCubeCollapse <- function(x) {
    .Call('_InVivoR_CxCubeCollapse', PACKAGE = 'InVivoR', x)
}

#' Coherence/Coherency/Phase Difference function
#' 
#' This function computes the coherence, coherency, and the phase difference between two wavelet transforms.
#' 
#' @param WT1 A complex matrix representing the wavelet transform.
#' @param WT2 A complex matrix representing the wavelet transform.
#' @param frequencies A vector indicating the frequencies which should be analysed.
#' @param samplingfrequency A double indicating the sampling frequency in Hz (default = 1000).
#' @param tKernelWidth A double indicating the sd as smoothing factor in the time domain (default = 0.01).
#' @param sKernelWidth A double indicating the smoothing factor in the scale domain (default = 0.6).
#' @return A list containing the coherency, coherence, and phase difference of the two wavelet transforms.
#' @export
WTCoherence <- function(WT1, WT2, frequencies, samplingfrequency = 1e3, tKernelWidth = 0.01, sKernelWidth = 0.6) {
    .Call('_InVivoR_WTCoherence', PACKAGE = 'InVivoR', WT1, WT2, frequencies, samplingfrequency, tKernelWidth, sKernelWidth)
}

#' Spike cut out
#' 
#' This function extracts spike shape matrices from an ampliflier matrix (rows = channels, columns = time).
#'
#' @param AmpMatrix A matrix with signal from the amplifier (rows = channels, columns = time).
#' @param SpikeIdx A matrix with signal from the amplifier (rows = channels, columns = time).
#' @param WINDOW An integer indicating the edges (default = 20).
#' @return Returns a vector with position of maximum amplitude and amplitude itself.
#' @export
SpikeCut <- function(AmpMatrix, SpikeIdx, WINDOW = 20L) {
    .Call('_InVivoR_SpikeCut', PACKAGE = 'InVivoR', AmpMatrix, SpikeIdx, WINDOW)
}

#' Spike median matrix
#' 
#' This function computes the median shape of spikes from a single spike cube.
#'
#' @param SpikeCube A cube containing matrices with isolated spikes (rows = channels, columns = time).
#' @return Returns a matrix with median spike shapes (rows = channels, columns = time).
#' @export
SpikeMed <- function(SpikeCube) {
    .Call('_InVivoR_SpikeMed', PACKAGE = 'InVivoR', SpikeCube)
}

#' Maximum amplitude channel
#' 
#' This function uses the median spike shape to find channel with maximum amplitude.
#' As input the function requires the previously computed median spike matrix with dimensions of n.row = clusters and n.col = channel count
#'
#' @param MedianSpikeMat A median matrix from arma_apply_median.
#' @return Returns a vector with position of maximum amplitude and amplitude itself.
#' @export
MaxChannel <- function(MedianSpikeMat) {
    .Call('_InVivoR_MaxChannel', PACKAGE = 'InVivoR', MedianSpikeMat)
}

#' Maximum amplitude channel
#' 
#' This function takes a list of single events and computes the channel with max amplitude and amplitude for all units in list.
#'
#' @param SpikeCubeList A list out of spike shape cubes.
#' @return Returns a list inlcuding the channel number and amplitude.
#' @export
ChannelFromList <- function(SpikeCubeList) {
    .Call('_InVivoR_ChannelFromList', PACKAGE = 'InVivoR', SpikeCubeList)
}

#' Spike location channel
#' 
#' This function is a wrapper to extract the channel location for any given unit based on the spike timings. It uses the spike 
#' indices, unit numbers, and the amplifier matrix (row = channels, Columns = time). It avoids using an apply function and 
#' directly accesses the data matrix.
#'
#' @param SpikeIdx A numeric vector with spike indices.
#' @param Units A numeric vector unit numbers.
#' @param AmpMatrix A matrix with signal from the amplifier (rows = channels, columns = time).
#' @return Returns a list inlcuding the channel number, amplitude and unit number.
#' @export
UnitChannel <- function(SpikeIdx, Units, AmpMatrix, WINDOW = 20L) {
    .Call('_InVivoR_UnitChannel', PACKAGE = 'InVivoR', SpikeIdx, Units, AmpMatrix, WINDOW)
}

#' Butterworth filter
#' 
#' This function returns a modified FFT.
#'
#' @param InputFFT A complex matrix from FFTW.
#' @param SamplingFrequency A double indicating sampling frequency.
#' @param ORDER An int as filtering order (default = 2).
#' @param f0 A double as cutoff frequency.
#' @param type A string indicating the filter type ("low", "high"). The default is "low".
#' @param CORES An int indicating the number of threads used (default = 1).
#' @return Complex armadillo column vector.
#' @export
BWFilterCpp <- function(InputFFT, SamplingFrequency, ORDER = 2L, f0 = 10, type = "low", CORES = 1L) {
    .Call('_InVivoR_BWFilterCpp', PACKAGE = 'InVivoR', InputFFT, SamplingFrequency, ORDER, f0, type, CORES)
}

#' FIR filtering
#' 
#' This function applies an FIR filter to a signal an returns the filtered trace.
#'
#' @param SIGNAL A numeric vector.
#' @param FIR_FILTER A numeric vector which can be used as FIR filter.
#' @param FiltFilt A bool indicating if "filtfilt" mode should be used.
#' @param BatchSize An integer indicating the starting batchsize of the trace (chunk size will be optimised for FFT).
#' @param CORES An integer indicating what number of cores should be used.
#' @return Returns numeric vector which is the FIR filtered original signal.
#' @export
FirFiltering <- function(SIGNAL, FIR_FILTER, FiltFilt = TRUE, BatchSize = 1e4L, CORES = 1L) {
    .Call('_InVivoR_FirFiltering', PACKAGE = 'InVivoR', SIGNAL, FIR_FILTER, FiltFilt, BatchSize, CORES)
}

#' Confidence interval for poisson train
#' 
#' Computes the confidence interval of a poisson train using an inverted gaussian
#' distribution. Based on the weighted average with the given distribution lamda
#' can be estimated. The confidence interval is then estimated by estimation through
#' Chisq-distribution.
#'
#' @param CountVector An integer vector of counts estimated by Spike CCF.
#' @param CONFLEVEL A double indicating the confidence-level (default = 0.95).
#' @param SD A double as standard deviation for a gaussian shape parameter (default = 0.6).
#' @param CENTREMIN A double as shape parameter determining the strength of centre exclusion (default = 0.6).
#' @param KERNELSIZE A double as length parameter for gaussian kernel (2*KERNELSIZE+1, default = 20).
#' @return Returns a list containing counts per bin, axis, random bin count, confidence-intervals with counts per bin.
#' @export
ConfIntPoisson <- function(CountVector, CONFLEVEL = 0.95, SD = 0.6, CENTREMIN = 0.6, KERNELSIZE = 20L) {
    .Call('_InVivoR_ConfIntPoisson', PACKAGE = 'InVivoR', CountVector, CONFLEVEL, SD, CENTREMIN, KERNELSIZE)
}

#' Spike cross-correlation function
#' 
#' The function will calculate the cross-correlation for spikes of the same or a different cell. 
#' The input arguments can be a vector containg timpoints (in seconds), two different vectors 
#' with timepoints or one vector with time points for all units and an integer vector containg 
#' the unit ID. The ouput will be depending on the input a single CCF or a list containing the 
#' CCF for all combinations in a matrix. Additional options include the computation of the confidence 
#' interval and the baseline activity.
#' 
#' @param x A numeric vector of times which has to be sorted in ascending order.
#' @param y A numeric vector of times which has to be sorted in ascending order.
#' @param UnitNr An integer vector containing the unit numbers in order of time occurence.
#' @param WINDOW_LENGTH An int as total window length in seconds (default = 1).
#' @param BIN_SIZE A double indicating the size of bins in seconds (default = 0.001).
#' @param BaselineFrequency A bool to indicate whether base line activity should be estimated (default = TRUE).
#' @param ConfidenceInterval A bool to indicate whether confidence interval should be estimated (default = TRUE).
#' @param ConfLevel A double indicating the confidence-level (default = 0.95).
#' @param SD A double as standard deviation for a gaussian shape parameter (default = 0.6).
#' @param CENTREMIN A double as shape parameter determining the strength of centre exclusion (default = 0.6).
#' @param KERNELSIZE A double as length parameter for gaussian kernel (2*KERNELSIZE+1, default = 20).
#' @return Returns a list containing counts per bin, axis, random bin count, confidence-intervals with counts per bin.
#' @export
SpikeCCF <- function(x, y = NULL, UnitNr = NULL, WINDOW_LENGTH = 1, BIN_SIZE = 0.001, BaselineFrequency = TRUE, ConfidenceInterval = TRUE, ConfLevel = 0.95, SD = 0.6, CENTREMIN = 0.6, KERNELSIZE = 20L) {
    .Call('_InVivoR_SpikeCCF', PACKAGE = 'InVivoR', x, y, UnitNr, WINDOW_LENGTH, BIN_SIZE, BaselineFrequency, ConfidenceInterval, ConfLevel, SD, CENTREMIN, KERNELSIZE)
}

#' Spike stimulation properties
#' 
#' This function assigns stimulation properties to every spike so that it can be incorporated in a table.
#' 
#' @param spike_idx An integer vector representing the spike time point as sampling point (index).
#' @param stim_mat_org A matrix with stimulation properties (from Pulse_Seq_correctrion).
#' @param block_mat_org A matrix with stimulation block properties..
#' @param sampling_rate An integer indicating the sampling frequency.
#' @param include_isolated A bool indicting whether isolated stimulation outside of blocks should be included.
#' @return Returns a matrix with stimulation properties for every spike ("onset", "peak_loc_offset", "peak_amp", "stim_length", "phase", "pulse", "sine", "ramp_front", "ramp_end", "frequency", "burst stim", "pulse_nr_block", "pulse_nr", "stimulation_block", "stimulation_timing", "pre", "post", "hyper_block", "hyper_block_frequency").
#' @export
spike_stim_properties <- function(spike_idx, stim_mat_org, block_mat_org, sampling_rate, include_isolated) {
    .Call('_InVivoR_spike_stim_properties', PACKAGE = 'InVivoR', spike_idx, stim_mat_org, block_mat_org, sampling_rate, include_isolated)
}

#' Phase lock analysis
#' 
#' This function computes the phase lock using the Rho vector length 
#' (strength of the locking) and the circular mean phase from a list containing 
#' wavelet transforms of epochs. The input list has to be flattend (vectorised) 
#' first.
#' 
#' @param input_mat A matrix with time on the x-axis.
#' @param from_point A starting point for baseline used for z-score.
#' @param to_point An end point for baseline used for z-score.
#' @return Returns a matrix with z-scores based on baseline as reference.
#' @export
mat_baseline_zscore <- function(input_mat, from_point, to_point) {
    .Call('_InVivoR_mat_baseline_zscore', PACKAGE = 'InVivoR', input_mat, from_point, to_point)
}

