### Make table from MI function output and CWT axis

#' @title Table for modulation index
#' 
#' @description A function to compute a data.table of the modulation index.
#' 
#' @name MITable
#' @param MIList List generated by MI_analysis() which includes necessary modulation indices.
#' @param GapFill double indicating the frequency gap in seconds (inverse of frequency).
#' 
#' @return Returns a data table with x/y coordinates and their corresponding modulation indices.
#' @export
MITable <- function(MIList, GapFill) {
  Var1 <- Var2 <- BottomX <- BottomY <- TopX <- TopY <- value <- NULL
  top_y <- 2^seq(to = log2(max(MIList$PowerFrequency))+GapFill/2,from = log2(min(MIList$PowerFrequency))+GapFill/2,GapFill)
  bottom_y <- 2^seq(to = log2(max(MIList$PowerFrequency))-GapFill/2,from = log2(min(MIList$PowerFrequency))-GapFill/2,GapFill)
  top_x <- 2^seq(to = log2(max(MIList$PhaseFrequency))+GapFill/2,from = log2(min(MIList$PhaseFrequency))+GapFill/2,GapFill)
  bottom_x <- 2^seq(to = log2(max(MIList$PhaseFrequency))-GapFill/2,from = log2(min(MIList$PhaseFrequency))-GapFill/2,GapFill)
  MI_table <- data.table::as.data.table(reshape2::melt(t(MIList$MI)))
  MI_table[,data.table::`:=`(TopX=NaN, BottomX=NaN, TopY=NaN, BottomY=NaN),]

  for(rowset in unique(MI_table[,Var2])) {
    data.table::set(MI_table, i=which(MI_table[,Var2]==rowset), j=7L,  value=bottom_y[rowset])
    data.table::set(MI_table, i=which(MI_table[,Var2]==rowset), j=6L,  value=top_y[rowset])
  }
  for(rowset in unique(MI_table[,Var1])) {
    data.table::set(MI_table, i=which(MI_table[,Var1]==rowset), j=5L,  value=bottom_x[rowset])
    data.table::set(MI_table, i=which(MI_table[,Var1]==rowset), j=4L,  value=top_x[rowset])
  }
  #Index <- NULL
  return(MI_table[,list(Index=value, TopX=TopX, BottomX=BottomX, TopY=TopY, BottomY=BottomY)])
}

#' @title Modulation Index Plot
#' 
#' @description Plot modulation index from table
#'
#' @name MIPlot
#' @param MITab data.table produced by MITable.
#' @param Colour Colour string based on viridis lookup table.
#' @param VLine Optional double for plotting vertical line.
#' @param HLine Optional double for plotting horizontal line.
#'
#' @return Returns a ggplot of the modulation index.
#' @export
MIPlot <- function(MITab, Colour = "magma", VLine = NULL, HLine = NULL) {
  BottomX <- BottomY <- TopX <- TopY <- Index <- NULL
  MI_plot <- ggplot2::ggplot(data = MITab, ggplot2::aes(ymin=BottomY, ymax=TopY, xmin=BottomX,xmax=TopX, fill=Index))+
    ggplot2::geom_rect()+
    viridis::scale_fill_viridis(option = Colour)+
    ggplot2::scale_x_continuous(expand=c(0,0))+
    ggplot2::scale_y_continuous(expand=c(0,0))+
    ggplot2::labs(fill="Modulation Index (MI)", x = "Phase Frequency (Hz)", y = "Amplitude Frequency (Hz)")+
    ggplot2::theme_classic()+
    ggplot2::theme(panel.grid.major = ggplot2::element_blank(), panel.grid.minor = ggplot2::element_blank())
  if(is.numeric(VLine)) {
    MI_plot <- MI_plot+
      ggplot2::geom_vline(xintercept=VLine, linetype="dashed", color="white", size=1)
  }
  if(is.numeric(HLine)) {
    MI_plot <- MI_plot+
      ggplot2::geom_hline(yintercept=HLine, linetype="dashed", color="white", size=1)
  }
  return(MI_plot)
}
